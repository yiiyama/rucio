#!/usr/bin/env python

from __future__ import division
from __future__ import print_function

import logging
import sys

import argparse

from rucio.core.rse import get_rse_id, get_rse_attribute, update_rse
from rucio.common import exception
from rucio.common.config import config_get
from rucio.db.sqla.session import transactional_session
from rucio.db.sqla import models

from rucio.core.lock import get_dataset_locks_by_rse_id
from rucio.core.replica import list_datasets_per_rse
from rucio.core.rule import list_rules
from rucio.api.did import list_dids
import rucio.core.rse as core_rse

logging.basicConfig(stream=sys.stdout,
                    level=getattr(logging,
                                  config_get('common', 'loglevel',
                                             raise_exception=False,
                                             default='DEBUG').upper()),
                    format='%(asctime)s\t%(process)d\t%(levelname)s\t%(message)s')

def get_parser():
    """
    Returns the argparse parser.
    """
    parser = argparse.ArgumentParser(description='First step for writing a decommissioning agent.')
    parser.add_argument('rse', action='store', nargs='+', help='RSE to decommission')
    #parser.add_argument('--dry-run', action='store_true', help='Dry run')
    parser.add_argument('--run', action='store_true', help='Actually run')
    return parser

# policies
JUST_DELETE, MOVE = range(2)

@transactional_session
def decommission_rse(rse, policy, dry_run=False, session=None):
    """
    Set RSE attributes for decommissioning (read=True, write=False, delete=True).

    :param rse:      Name of the RSE.
    :param session:  The database session.
    """

    logging.info('Decommissioning: Preparing RSE %(rse)s' % locals())
    
    try:
        rse_id = get_rse_id(rse, session=session, include_deleted=False)
    except exception.RSENotFound:
        logging.warning('RSE %(rse) not found' % locals())
        return False

    #logging.info(list(list_dids(scope='user.yiiyama', filters={'name': '*'}, type='dataset')))
    #return True

    # Set the RSE attributes
    for key, value in [('availability_read', True), ('availability_write', False), ('availability_delete', True), ('greedyDeletion', True)]:
        current = get_rse_attribute(key, rse_id=rse_id)
        if current is not value:
            logging.debug('RSE: %(rse)s, updating attribute %(key)s (%(current)s => %(value)s)' % locals())
            if not dry_run:
                update_rse(rse_id, {key: value}, session=session)

    print(core_rse.get_rse(rse_id, session=session))
    print(core_rse.rse_is_empty(rse_id, session=session))

    # List all datasets on the RSE
    # (We have no straightforward way of listing the rules per RSE, so we go from datasets to rules)
    datasets_with_no_rule = []
    logging.info(list(list_datasets_per_rse(rse_id, filters={}, session=session)))
    for row in list_datasets_per_rse(rse_id, session=session):
        logging.info(row)
        rule = list_rules(filters={'scope': row['scope'], 'name': row['name']}, session=session)
        logging.info(rule)
        break

    return True


    dataset_locks = get_dataset_locks_by_rse_id(rse_id, session=session)
    for lock in dataset_locks:
        print(lock)

    if policy == JUST_DELETE:
        pass
        # Delete the replication rules

        # Delete the remaining locks

        # Delete the replicas

    return True


if __name__ == "__main__":
    parser = get_parser()
    args = parser.parse_args()

    for rse in args.rse:
        decommission_rse(rse, JUST_DELETE, dry_run=(not args.run))
